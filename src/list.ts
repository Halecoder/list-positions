import { ItemList } from "./item_list";
import { Node, NodeDesc } from "./node";
import { Order } from "./order";
import { Position } from "./position";
import { ArrayItemManager, SparseArray } from "./sparse_array";

/**
 * TODO: Explain format (obvious triple-map rep). JSON ordering guarantees.
 */
export type ListSavedState<T> = {
  [creatorID: string]: {
    [timestamp: number]: {
      [valueIndex: number]: T;
    };
  };
};

function saveArray<T>(arr: SparseArray<T[]>): { [valueIndex: number]: T } {
  const savedArr: { [valueIndex: number]: T } = {};
  let index = 0;
  for (let i = 0; i < arr.length; i++) {
    if (i % 2 === 0) {
      for (const value of arr[i] as T[]) {
        savedArr[index] = value;
        index++;
      }
    } else index += arr[i] as number;
  }
  return savedArr;
}

function loadArray<T>(savedArr: { [valueIndex: number]: T }): SparseArray<T[]> {
  const arr: SparseArray<T[]> = [[]];
  let nextIndex = 0;
  // Since savedArr's keys are nonnegative integers, this loop visits them
  // in numeric order.
  for (const [indexStr, value] of Object.entries(savedArr)) {
    const index = Number.parseInt(indexStr);
    if (isNaN(index)) {
      // We were passed an array-like object but with extra properties.
      // Break on the first such property, which appears after all valueIndex keys.
      break;
    }
    if (index === nextIndex) {
      // Append to previous T[].
      (arr[arr.length - 1] as T[]).push(value);
    } else {
      // Indicate deleted values in between.
      arr.push(index - nextIndex, [value]);
    }
    nextIndex = index + 1;
  }

  // If savedArr was empty, return [] instead of [[]].
  if (arr.length === 1 && (arr[0] as T[]).length === 0) return [];
  else return arr;
}

/**
 * A local (non-collaborative) data structure mapping [[Position]]s to
 * values, in list order.
 *
 * You can use a LocalList to maintain a sorted, indexable view of a
 * [[CValueList]], [[CList]], or [[CText]]'s values.
 * For example, when using a [[CList]],
 * you could store its archived values in a LocalList.
 * That would let you iterate over the archived values in list order.
 *
 * To construct a LocalList that uses an existing list's positions, pass
 * that list's `totalOrder` to our constructor.
 *
 * It is *not* safe to modify a LocalList while iterating over it. The iterator
 * will attempt to throw an exception if it detects such modification,
 * but this is not guaranteed.
 *
 * @typeParam T The value type.
 */
export class List<T> {
  readonly order: Order;
  private readonly itemList: ItemList<T[], T>;

  /**
   * Constructs a LocalList whose allowed [[Position]]s are given by
   * `source`.
   *
   * Using positions that were not generated by `source` (or a replica of
   * `source`) will cause undefined behavior.
   *
   * @param order The source for positions that may be used with this
   * LocalList.
   */
  constructor(order?: Order) {
    this.order = order ?? new Order();
    this.itemList = new ItemList(this.order, new ArrayItemManager());
  }

  // TODO: way to convert to/from regular arrays { lexPos: value }[] (Gurgen suggestion).

  // ----------
  // Mutators
  // ----------

  /**
   * Sets the value at `pos`.
   *
   * @throws TODO pos invalid
   */
  set(pos: Position, value: T): void;
  /**
   * TODO
   *
   * If multiple values are given, they are set starting at startPos
   * in the same Node. Note these might not be contiguous anymore,
   * unless they are new (no causally-future Positions set yet).
   * @param startPos
   * @param sameNodeValues
   */
  set(startPos: Position, ...sameNodeValues: T[]): void;
  set(startPos: Position, ...values: T[]): void {
    // TODO: return existing.save()? Likewise in delete, setAt?, deleteAt?
    this.itemList.set(startPos, values);
  }

  /**
   * Sets the value at index.
   *
   * @throws If index is not in `[0, this.length)`.
   */
  setAt(index: number, value: T): void {
    this.set(this.positionAt(index), value);
  }

  /**
   * Deletes the given position, making it no longer
   * present in this list.
   *
   * @returns Whether the position was actually deleted, i.e.,
   * it was initially present.
   */
  delete(pos: Position): void;
  delete(startPos: Position, sameNodeCount: number): void;
  delete(startPos: Position, count = 1): void {
    this.itemList.delete(startPos, count);
  }

  /**
   * Deletes the value at index.
   *
   * @throws If index is not in `[0, this.length)`.
   */
  deleteAt(index: number): void {
    this.delete(this.positionAt(index));
  }

  /**
   * Deletes every value in the list.
   *
   * The Order is unaffected (retains all Nodes).
   */
  clear() {
    this.itemList.clear();
  }

  /**
   *
   * @param prevPos
   * @param values
   * @returns { first value's new position, createdNodeDesc if created by Order }.
   * If values.length > 1, their positions start at pos using the same Node
   * with increasing valueIndex.
   * If values.length = 0, a new position is created but the List state is not
   * changed - can use this instead of calling Order.createPosition directly.
   * @throws If prevPos is order.maxPosition.
   */
  insert(
    prevPos: Position,
    ...values: T[]
  ): { startPos: Position; createdNodeDesc: NodeDesc | null } {
    return this.itemList.insert(prevPos, values);
  }

  /**
   *
   * @param index
   * @param values
   * @returns
   * @throws If index is this.length and our last value is at order.maxPosition.
   */
  insertAt(
    index: number,
    ...values: T[]
  ): { startPos: Position; createdNodeDesc: NodeDesc | null } {
    return this.itemList.insertAt(index, values);
  }

  // ----------
  // Accessors
  // ----------

  /**
   * Returns the value at position, or undefined if it is not currently present
   * ([[hasPosition]] returns false).
   */
  get(pos: Position): T | undefined {
    return this.itemList.get(pos);
  }

  /**
   * Returns the value currently at index.
   *
   * @throws If index is not in `[0, this.length)`.
   * Note that this differs from an ordinary Array,
   * which would instead return undefined.
   */
  getAt(index: number): T {
    return this.itemList.getAt(index);
  }

  /**
   * Returns whether position is currently present in the list,
   * i.e., its value is present.
   */
  has(pos: Position): boolean {
    return this.itemList.has(pos);
  }

  /**
   * Returns the current index of position.
   *
   * If position is not currently present in the list
   * ([[hasPosition]] returns false), then the result depends on searchDir:
   * - "none" (default): Returns -1.
   * - "left": Returns the next index to the left of position.
   * If there are no values to the left of position,
   * returns -1.
   * - "right": Returns the next index to the right of position.
   * If there are no values to the right of position,
   * returns [[length]].
   *
   * To find the index where a position would be if
   * present, use `searchDir = "right"`.
   */
  indexOfPosition(
    pos: Position,
    searchDir: "none" | "left" | "right" = "none"
  ): number {
    return this.itemList.indexOfPosition(pos, searchDir);
  }

  /**
   * Returns the position currently at index.
   *
   * Won't return minPosition or maxPosition. TODO: actually, will if they're
   * part of the list - check that code is compatible.
   */
  positionAt(index: number): Position {
    return this.itemList.positionAt(index);
  }

  /**
   * The length of the list.
   */
  get length() {
    return this.itemList.length;
  }

  // ----------
  // Iterators
  // ----------

  /** Returns an iterator for values in the list, in list order. */
  [Symbol.iterator](): IterableIterator<T> {
    return this.values();
  }

  /**
   * Returns an iterator for values in the list, in list order.
   *
   * Args as in Array.slice.
   */
  *values(start?: number, end?: number): IterableIterator<T> {
    for (const [, value] of this.entries(start, end)) yield value;
  }

  /**
   * Returns a copy of a section of this list, as an array.
   *
   * Args as in Array.slice.
   */
  slice(start?: number, end?: number): T[] {
    return [...this.values(start, end)];
  }

  /**
   * Returns an iterator for present positions, in list order.
   *
   * Args as in Array.slice.
   */
  *positions(start?: number, end?: number): IterableIterator<Position> {
    for (const [pos] of this.entries(start, end)) yield pos;
  }

  /**
   * Returns an iterator of [pos, value, index] tuples for every
   * value in the list, in list order.
   *
   * Args as in Array.slice.
   */
  entries(
    start?: number,
    end?: number
  ): IterableIterator<[pos: Position, value: T, index: number]> {
    return this.itemList.entries(start, end);
  }

  // ----------
  // Save & Load
  // ----------

  saveOneNode(node: Node): {
    [valueIndex: number]: T;
  } {
    const arr = this.itemList.saveOneNode(node);
    if (arr === undefined) return {};
    return saveArray(arr);
  }

  /**
   * Overwrites all of node's existing values - so non-present keys become
   * deleted, even if they come after the last present key.
   *
   * Note that values might not be contiguous in the list.
   */
  loadOneNode(
    node: Node,
    valuesObj: {
      [valueIndex: number]: T;
    }
  ): void {
    this.itemList.loadOneNode(node, loadArray(valuesObj));
  }

  /**
   * Returns saved state describing the current state of this LocalList,
   * including its values.
   *
   * The saved state may later be passed to [[load]]
   * on a new instance of LocalList, to reconstruct the
   * same list state.
   *
   * Only saves values, not Order. "Natural" format; order
   * guarantees.
   */
  save(): ListSavedState<T> {
    return this.itemList.save(saveArray);
  }

  /**
   * Loads saved state. The saved state must be from
   * a call to [[save]] on a LocalList whose `source`
   * constructor argument was a replica of this's
   * `source`, so that we can understand the
   * saved state's Positions.
   *
   * Overwrites whole state - not state-based merge.
   *
   * @param savedState Saved state from a List's
   * [[save]] call.
   */
  load(savedState: ListSavedState<T>): void {
    this.itemList.load(savedState, loadArray);
  }
}
